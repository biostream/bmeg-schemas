// Code generated by protoc-gen-go.
// source: matrix.proto
// DO NOT EDIT!

package bmeg

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ExpressionScale int32

const (
	ExpressionScale_UNKNOWN    ExpressionScale = 0
	ExpressionScale_READ_COUNT ExpressionScale = 1
	ExpressionScale_TPKM       ExpressionScale = 2
	ExpressionScale_RPKM       ExpressionScale = 3
)

var ExpressionScale_name = map[int32]string{
	0: "UNKNOWN",
	1: "READ_COUNT",
	2: "TPKM",
	3: "RPKM",
}
var ExpressionScale_value = map[string]int32{
	"UNKNOWN":    0,
	"READ_COUNT": 1,
	"TPKM":       2,
	"RPKM":       3,
}

func (x ExpressionScale) String() string {
	return proto.EnumName(ExpressionScale_name, int32(x))
}
func (ExpressionScale) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

type GeneExpression struct {
	Id     string          `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Gid    string          `protobuf:"bytes,2,opt,name=gid" json:"gid,omitempty"`
	Type   string          `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	Source string          `protobuf:"bytes,4,opt,name=source" json:"source,omitempty"`
	Alias  []string        `protobuf:"bytes,5,rep,name=alias" json:"alias,omitempty"`
	Scale  ExpressionScale `protobuf:"varint,6,opt,name=scale,enum=bmeg.ExpressionScale" json:"scale,omitempty"`
	// Target: Biosample
	BiosampleId string             `protobuf:"bytes,7,opt,name=biosample_id" json:"biosample_id,omitempty"`
	Expressions map[string]float64 `protobuf:"bytes,8,rep,name=expressions" json:"expressions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
}

func (m *GeneExpression) Reset()                    { *m = GeneExpression{} }
func (m *GeneExpression) String() string            { return proto.CompactTextString(m) }
func (*GeneExpression) ProtoMessage()               {}
func (*GeneExpression) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *GeneExpression) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GeneExpression) GetGid() string {
	if m != nil {
		return m.Gid
	}
	return ""
}

func (m *GeneExpression) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *GeneExpression) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *GeneExpression) GetAlias() []string {
	if m != nil {
		return m.Alias
	}
	return nil
}

func (m *GeneExpression) GetScale() ExpressionScale {
	if m != nil {
		return m.Scale
	}
	return ExpressionScale_UNKNOWN
}

func (m *GeneExpression) GetBiosampleId() string {
	if m != nil {
		return m.BiosampleId
	}
	return ""
}

func (m *GeneExpression) GetExpressions() map[string]float64 {
	if m != nil {
		return m.Expressions
	}
	return nil
}

// Cohort is for groups of Biosamples
type Cohort struct {
	Id          string   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Gid         string   `protobuf:"bytes,2,opt,name=gid" json:"gid,omitempty"`
	Type        string   `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	Name        string   `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	Location    string   `protobuf:"bytes,5,opt,name=location" json:"location,omitempty"`
	Description string   `protobuf:"bytes,6,opt,name=description" json:"description,omitempty"`
	HasSample   []string `protobuf:"bytes,7,rep,name=hasSample" json:"hasSample,omitempty"`
	HasMatrix   []string `protobuf:"bytes,8,rep,name=hasMatrix" json:"hasMatrix,omitempty"`
}

func (m *Cohort) Reset()                    { *m = Cohort{} }
func (m *Cohort) String() string            { return proto.CompactTextString(m) }
func (*Cohort) ProtoMessage()               {}
func (*Cohort) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *Cohort) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Cohort) GetGid() string {
	if m != nil {
		return m.Gid
	}
	return ""
}

func (m *Cohort) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Cohort) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cohort) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Cohort) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Cohort) GetHasSample() []string {
	if m != nil {
		return m.HasSample
	}
	return nil
}

func (m *Cohort) GetHasMatrix() []string {
	if m != nil {
		return m.HasMatrix
	}
	return nil
}

// IndividualCohort is for groups of Individuals
type IndividualCohort struct {
	Id          string   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Gid         string   `protobuf:"bytes,2,opt,name=gid" json:"gid,omitempty"`
	Type        string   `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	Name        string   `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	Location    string   `protobuf:"bytes,5,opt,name=location" json:"location,omitempty"`
	Description string   `protobuf:"bytes,6,opt,name=description" json:"description,omitempty"`
	HasMember   []string `protobuf:"bytes,7,rep,name=hasMember" json:"hasMember,omitempty"`
}

func (m *IndividualCohort) Reset()                    { *m = IndividualCohort{} }
func (m *IndividualCohort) String() string            { return proto.CompactTextString(m) }
func (*IndividualCohort) ProtoMessage()               {}
func (*IndividualCohort) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *IndividualCohort) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *IndividualCohort) GetGid() string {
	if m != nil {
		return m.Gid
	}
	return ""
}

func (m *IndividualCohort) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *IndividualCohort) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *IndividualCohort) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *IndividualCohort) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *IndividualCohort) GetHasMember() []string {
	if m != nil {
		return m.HasMember
	}
	return nil
}

type DoubleVector struct {
	Id     string             `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Gid    string             `protobuf:"bytes,2,opt,name=gid" json:"gid,omitempty"`
	Type   string             `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	Values map[string]float64 `protobuf:"bytes,4,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
}

func (m *DoubleVector) Reset()                    { *m = DoubleVector{} }
func (m *DoubleVector) String() string            { return proto.CompactTextString(m) }
func (*DoubleVector) ProtoMessage()               {}
func (*DoubleVector) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *DoubleVector) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DoubleVector) GetGid() string {
	if m != nil {
		return m.Gid
	}
	return ""
}

func (m *DoubleVector) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *DoubleVector) GetValues() map[string]float64 {
	if m != nil {
		return m.Values
	}
	return nil
}

type CohortMatrix struct {
	Id          string   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Gid         string   `protobuf:"bytes,2,opt,name=gid" json:"gid,omitempty"`
	Type        string   `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	Method      string   `protobuf:"bytes,4,opt,name=method" json:"method,omitempty"`
	HasVector   []string `protobuf:"bytes,5,rep,name=hasVector" json:"hasVector,omitempty"`
	HasKeyspace []string `protobuf:"bytes,6,rep,name=hasKeyspace" json:"hasKeyspace,omitempty"`
}

func (m *CohortMatrix) Reset()                    { *m = CohortMatrix{} }
func (m *CohortMatrix) String() string            { return proto.CompactTextString(m) }
func (*CohortMatrix) ProtoMessage()               {}
func (*CohortMatrix) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *CohortMatrix) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CohortMatrix) GetGid() string {
	if m != nil {
		return m.Gid
	}
	return ""
}

func (m *CohortMatrix) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CohortMatrix) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *CohortMatrix) GetHasVector() []string {
	if m != nil {
		return m.HasVector
	}
	return nil
}

func (m *CohortMatrix) GetHasKeyspace() []string {
	if m != nil {
		return m.HasKeyspace
	}
	return nil
}

type Keyspace struct {
	Id   string   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Gid  string   `protobuf:"bytes,2,opt,name=gid" json:"gid,omitempty"`
	Type string   `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	Name string   `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	Keys []string `protobuf:"bytes,5,rep,name=keys" json:"keys,omitempty"`
}

func (m *Keyspace) Reset()                    { *m = Keyspace{} }
func (m *Keyspace) String() string            { return proto.CompactTextString(m) }
func (*Keyspace) ProtoMessage()               {}
func (*Keyspace) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *Keyspace) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Keyspace) GetGid() string {
	if m != nil {
		return m.Gid
	}
	return ""
}

func (m *Keyspace) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Keyspace) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Keyspace) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

type MatrixVectorEdge struct {
	Type    string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	In      string `protobuf:"bytes,2,opt,name=in" json:"in,omitempty"`
	Out     string `protobuf:"bytes,3,opt,name=out" json:"out,omitempty"`
	RowName string `protobuf:"bytes,4,opt,name=rowName" json:"rowName,omitempty"`
}

func (m *MatrixVectorEdge) Reset()                    { *m = MatrixVectorEdge{} }
func (m *MatrixVectorEdge) String() string            { return proto.CompactTextString(m) }
func (*MatrixVectorEdge) ProtoMessage()               {}
func (*MatrixVectorEdge) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

func (m *MatrixVectorEdge) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MatrixVectorEdge) GetIn() string {
	if m != nil {
		return m.In
	}
	return ""
}

func (m *MatrixVectorEdge) GetOut() string {
	if m != nil {
		return m.Out
	}
	return ""
}

func (m *MatrixVectorEdge) GetRowName() string {
	if m != nil {
		return m.RowName
	}
	return ""
}

type MatrixAnalysis struct {
	Id           string   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Gid          string   `protobuf:"bytes,2,opt,name=gid" json:"gid,omitempty"`
	Type         string   `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	SourceMatrix []string `protobuf:"bytes,4,rep,name=sourceMatrix" json:"sourceMatrix,omitempty"`
	ResultMatrix []string `protobuf:"bytes,5,rep,name=resultMatrix" json:"resultMatrix,omitempty"`
}

func (m *MatrixAnalysis) Reset()                    { *m = MatrixAnalysis{} }
func (m *MatrixAnalysis) String() string            { return proto.CompactTextString(m) }
func (*MatrixAnalysis) ProtoMessage()               {}
func (*MatrixAnalysis) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7} }

func (m *MatrixAnalysis) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MatrixAnalysis) GetGid() string {
	if m != nil {
		return m.Gid
	}
	return ""
}

func (m *MatrixAnalysis) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MatrixAnalysis) GetSourceMatrix() []string {
	if m != nil {
		return m.SourceMatrix
	}
	return nil
}

func (m *MatrixAnalysis) GetResultMatrix() []string {
	if m != nil {
		return m.ResultMatrix
	}
	return nil
}

func init() {
	proto.RegisterType((*GeneExpression)(nil), "bmeg.GeneExpression")
	proto.RegisterType((*Cohort)(nil), "bmeg.Cohort")
	proto.RegisterType((*IndividualCohort)(nil), "bmeg.IndividualCohort")
	proto.RegisterType((*DoubleVector)(nil), "bmeg.DoubleVector")
	proto.RegisterType((*CohortMatrix)(nil), "bmeg.CohortMatrix")
	proto.RegisterType((*Keyspace)(nil), "bmeg.Keyspace")
	proto.RegisterType((*MatrixVectorEdge)(nil), "bmeg.MatrixVectorEdge")
	proto.RegisterType((*MatrixAnalysis)(nil), "bmeg.MatrixAnalysis")
	proto.RegisterEnum("bmeg.ExpressionScale", ExpressionScale_name, ExpressionScale_value)
}

func init() { proto.RegisterFile("matrix.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 520 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0xbd, 0x6f, 0xd3, 0x40,
	0x14, 0xc7, 0xb1, 0xe3, 0x24, 0xcf, 0x6e, 0x6a, 0xdc, 0x20, 0x9d, 0x18, 0x50, 0x64, 0x81, 0x14,
	0x21, 0x91, 0x21, 0x2c, 0xa8, 0x5b, 0x69, 0x23, 0x04, 0x51, 0x5c, 0xd4, 0x2f, 0xc6, 0xea, 0x6c,
	0x3f, 0x25, 0xa7, 0xda, 0x3e, 0xeb, 0xce, 0x2e, 0xf5, 0x08, 0x23, 0x33, 0x7f, 0x30, 0xf2, 0x9d,
	0x1b, 0x42, 0x17, 0x02, 0x43, 0xb7, 0x7b, 0x2f, 0x97, 0xdf, 0xfb, 0x7d, 0xbc, 0x33, 0xb8, 0x19,
	0x2d, 0x05, 0xbb, 0x9b, 0x16, 0x82, 0x97, 0xdc, 0xb7, 0xa2, 0x0c, 0x57, 0xc1, 0xf7, 0x0e, 0x0c,
	0x3f, 0x60, 0x8e, 0xf3, 0xbb, 0x42, 0xa0, 0x94, 0x8c, 0xe7, 0x3e, 0x40, 0x87, 0x25, 0xc4, 0x18,
	0x1b, 0x93, 0x81, 0xef, 0x80, 0xb9, 0x62, 0x09, 0xe9, 0xa8, 0xc2, 0x05, 0xab, 0xac, 0x0b, 0x24,
	0xa6, 0xaa, 0x86, 0x60, 0x4b, 0x5e, 0x89, 0x18, 0x89, 0xa5, 0xea, 0x3d, 0xe8, 0xd2, 0x94, 0x51,
	0x49, 0xba, 0x63, 0x73, 0x32, 0xf0, 0x5f, 0x42, 0x57, 0xc6, 0x34, 0x45, 0x62, 0x8f, 0x8d, 0xc9,
	0x70, 0xf6, 0x6c, 0xda, 0x8c, 0x9b, 0xfe, 0x1e, 0x73, 0xde, 0xfc, 0xe8, 0x8f, 0xc0, 0x8d, 0x18,
	0x97, 0x34, 0x2b, 0x52, 0xbc, 0x66, 0x09, 0xe9, 0x29, 0xa8, 0x43, 0x70, 0x70, 0x73, 0x51, 0x92,
	0xfe, 0xd8, 0x9c, 0x38, 0xb3, 0x57, 0x1a, 0xe1, 0x4f, 0xb2, 0x5b, 0x80, 0x72, 0x9e, 0x97, 0xa2,
	0x7e, 0x3e, 0x03, 0xef, 0x61, 0xaf, 0x51, 0x71, 0x83, 0x75, 0x2b, 0x69, 0x0f, 0xba, 0xb7, 0x34,
	0xad, 0x50, 0x89, 0x32, 0x0e, 0x3b, 0xef, 0x8c, 0xe0, 0x87, 0x01, 0xf6, 0x31, 0x5f, 0x73, 0x51,
	0xee, 0x2a, 0xde, 0x05, 0x2b, 0xa7, 0xd9, 0xbd, 0x74, 0x0f, 0xfa, 0x29, 0x8f, 0x69, 0xc9, 0x78,
	0x4e, 0xba, 0xaa, 0x73, 0x00, 0x4e, 0x82, 0x32, 0x16, 0xac, 0x50, 0x4d, 0x5b, 0x35, 0x9f, 0xc2,
	0x60, 0x4d, 0xe5, 0xb9, 0x12, 0x4b, 0x7a, 0xca, 0x25, 0xdd, 0x5a, 0xaa, 0x5c, 0x94, 0xce, 0x41,
	0xf0, 0xcd, 0x00, 0xef, 0x63, 0x9e, 0xb0, 0x5b, 0x96, 0x54, 0x34, 0x7d, 0x34, 0x5a, 0x4b, 0xcc,
	0x22, 0x14, 0x9a, 0x56, 0xf0, 0xd3, 0x00, 0xf7, 0x84, 0x57, 0x51, 0x8a, 0x57, 0x18, 0x97, 0x5c,
	0xec, 0x3a, 0x7f, 0x0a, 0xb6, 0xf2, 0x56, 0x12, 0x4b, 0x65, 0xf6, 0x42, 0x67, 0xb6, 0x0d, 0x35,
	0xbd, 0x52, 0x17, 0x74, 0x58, 0x6f, 0xc0, 0xd9, 0x2a, 0xff, 0x9a, 0x53, 0x06, 0xae, 0xf6, 0x43,
	0x1b, 0xf6, 0x0f, 0x9b, 0x9a, 0x61, 0xb9, 0xe6, 0x49, 0xeb, 0x8b, 0x16, 0xac, 0xe9, 0xb4, 0xdb,
	0x7a, 0x00, 0xce, 0x9a, 0xca, 0x05, 0xd6, 0xb2, 0xa0, 0x71, 0xb3, 0xb3, 0x8d, 0x0b, 0x4b, 0xe8,
	0xdf, 0x77, 0xfe, 0x2f, 0x00, 0x17, 0xac, 0x1b, 0xac, 0xdb, 0x17, 0x11, 0x7c, 0x02, 0x4f, 0xf3,
	0xd6, 0x93, 0xe7, 0xc9, 0x0a, 0x37, 0xff, 0xd6, 0xc0, 0xcd, 0x90, 0xbc, 0xc5, 0x75, 0xc0, 0xe4,
	0x55, 0xd9, 0xc2, 0xee, 0x43, 0x4f, 0xf0, 0xaf, 0xe1, 0x06, 0x39, 0x88, 0x61, 0xa8, 0xb1, 0x8e,
	0x72, 0x9a, 0xd6, 0x92, 0xc9, 0x5d, 0x09, 0x8e, 0xc0, 0xd5, 0xaf, 0xb6, 0xdd, 0x39, 0x4b, 0xc9,
	0x1f, 0x81, 0x2b, 0x50, 0x56, 0x69, 0x6b, 0xac, 0x26, 0xfc, 0xfa, 0x3d, 0xec, 0x3f, 0x7c, 0xaf,
	0x0e, 0xf4, 0x2e, 0xc3, 0x45, 0x78, 0xfa, 0x25, 0xf4, 0x9e, 0xf8, 0x43, 0x80, 0xb3, 0xf9, 0xd1,
	0xc9, 0xf5, 0xf1, 0xe9, 0x65, 0x78, 0xe1, 0x19, 0x7e, 0x1f, 0xac, 0x8b, 0xcf, 0x8b, 0xa5, 0xd7,
	0x69, 0x4e, 0x67, 0xcd, 0xc9, 0x8c, 0x6c, 0xf5, 0xb1, 0x79, 0xfb, 0x2b, 0x00, 0x00, 0xff, 0xff,
	0x87, 0x21, 0x00, 0xca, 0x7c, 0x04, 0x00, 0x00,
}
