// Code generated by protoc-gen-go.
// source: pico.proto
// DO NOT EDIT!

package bmeg

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type List struct {
	Items []*Expression `protobuf:"bytes,3,rep,name=items" json:"items,omitempty"`
}

func (m *List) Reset()                    { *m = List{} }
func (m *List) String() string            { return proto.CompactTextString(m) }
func (*List) ProtoMessage()               {}
func (*List) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{0} }

func (m *List) GetItems() []*Expression {
	if m != nil {
		return m.Items
	}
	return nil
}

type Condition struct {
	Predicate *Expression `protobuf:"bytes,1,opt,name=predicate" json:"predicate,omitempty"`
	Truth     *Expression `protobuf:"bytes,2,opt,name=truth" json:"truth,omitempty"`
	Falsehood *Expression `protobuf:"bytes,3,opt,name=falsehood" json:"falsehood,omitempty"`
}

func (m *Condition) Reset()                    { *m = Condition{} }
func (m *Condition) String() string            { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()               {}
func (*Condition) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{1} }

func (m *Condition) GetPredicate() *Expression {
	if m != nil {
		return m.Predicate
	}
	return nil
}

func (m *Condition) GetTruth() *Expression {
	if m != nil {
		return m.Truth
	}
	return nil
}

func (m *Condition) GetFalsehood() *Expression {
	if m != nil {
		return m.Falsehood
	}
	return nil
}

type Fn struct {
	Arguments []string    `protobuf:"bytes,1,rep,name=arguments" json:"arguments,omitempty"`
	Body      *Expression `protobuf:"bytes,2,opt,name=body" json:"body,omitempty"`
}

func (m *Fn) Reset()                    { *m = Fn{} }
func (m *Fn) String() string            { return proto.CompactTextString(m) }
func (*Fn) ProtoMessage()               {}
func (*Fn) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{2} }

func (m *Fn) GetArguments() []string {
	if m != nil {
		return m.Arguments
	}
	return nil
}

func (m *Fn) GetBody() *Expression {
	if m != nil {
		return m.Body
	}
	return nil
}

type Binding struct {
	Symbol     string      `protobuf:"bytes,1,opt,name=symbol" json:"symbol,omitempty"`
	Expression *Expression `protobuf:"bytes,2,opt,name=expression" json:"expression,omitempty"`
}

func (m *Binding) Reset()                    { *m = Binding{} }
func (m *Binding) String() string            { return proto.CompactTextString(m) }
func (*Binding) ProtoMessage()               {}
func (*Binding) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{3} }

func (m *Binding) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *Binding) GetExpression() *Expression {
	if m != nil {
		return m.Expression
	}
	return nil
}

type Let struct {
	Bindings []*Binding  `protobuf:"bytes,1,rep,name=bindings" json:"bindings,omitempty"`
	Body     *Expression `protobuf:"bytes,2,opt,name=body" json:"body,omitempty"`
}

func (m *Let) Reset()                    { *m = Let{} }
func (m *Let) String() string            { return proto.CompactTextString(m) }
func (*Let) ProtoMessage()               {}
func (*Let) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{4} }

func (m *Let) GetBindings() []*Binding {
	if m != nil {
		return m.Bindings
	}
	return nil
}

func (m *Let) GetBody() *Expression {
	if m != nil {
		return m.Body
	}
	return nil
}

type Apply struct {
	Function  *Expression   `protobuf:"bytes,1,opt,name=function" json:"function,omitempty"`
	Arguments []*Expression `protobuf:"bytes,2,rep,name=arguments" json:"arguments,omitempty"`
}

func (m *Apply) Reset()                    { *m = Apply{} }
func (m *Apply) String() string            { return proto.CompactTextString(m) }
func (*Apply) ProtoMessage()               {}
func (*Apply) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{5} }

func (m *Apply) GetFunction() *Expression {
	if m != nil {
		return m.Function
	}
	return nil
}

func (m *Apply) GetArguments() []*Expression {
	if m != nil {
		return m.Arguments
	}
	return nil
}

type Expression struct {
	// Types that are valid to be assigned to Value:
	//	*Expression_Nil
	//	*Expression_Symbol
	//	*Expression_String_
	//	*Expression_Number
	//	*Expression_List
	//	*Expression_Condition
	//	*Expression_Fn
	//	*Expression_Let
	//	*Expression_Apply
	Value isExpression_Value `protobuf_oneof:"value"`
}

func (m *Expression) Reset()                    { *m = Expression{} }
func (m *Expression) String() string            { return proto.CompactTextString(m) }
func (*Expression) ProtoMessage()               {}
func (*Expression) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{6} }

type isExpression_Value interface {
	isExpression_Value()
}

type Expression_Nil struct {
	Nil bool `protobuf:"varint,1,opt,name=nil,oneof"`
}
type Expression_Symbol struct {
	Symbol string `protobuf:"bytes,2,opt,name=symbol,oneof"`
}
type Expression_String_ struct {
	String_ string `protobuf:"bytes,3,opt,name=string,oneof"`
}
type Expression_Number struct {
	Number float64 `protobuf:"fixed64,4,opt,name=number,oneof"`
}
type Expression_List struct {
	List *List `protobuf:"bytes,5,opt,name=list,oneof"`
}
type Expression_Condition struct {
	Condition *Condition `protobuf:"bytes,7,opt,name=condition,oneof"`
}
type Expression_Fn struct {
	Fn *Fn `protobuf:"bytes,6,opt,name=fn,oneof"`
}
type Expression_Let struct {
	Let *Let `protobuf:"bytes,8,opt,name=let,oneof"`
}
type Expression_Apply struct {
	Apply *Apply `protobuf:"bytes,9,opt,name=apply,oneof"`
}

func (*Expression_Nil) isExpression_Value()       {}
func (*Expression_Symbol) isExpression_Value()    {}
func (*Expression_String_) isExpression_Value()   {}
func (*Expression_Number) isExpression_Value()    {}
func (*Expression_List) isExpression_Value()      {}
func (*Expression_Condition) isExpression_Value() {}
func (*Expression_Fn) isExpression_Value()        {}
func (*Expression_Let) isExpression_Value()       {}
func (*Expression_Apply) isExpression_Value()     {}

func (m *Expression) GetValue() isExpression_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Expression) GetNil() bool {
	if x, ok := m.GetValue().(*Expression_Nil); ok {
		return x.Nil
	}
	return false
}

func (m *Expression) GetSymbol() string {
	if x, ok := m.GetValue().(*Expression_Symbol); ok {
		return x.Symbol
	}
	return ""
}

func (m *Expression) GetString_() string {
	if x, ok := m.GetValue().(*Expression_String_); ok {
		return x.String_
	}
	return ""
}

func (m *Expression) GetNumber() float64 {
	if x, ok := m.GetValue().(*Expression_Number); ok {
		return x.Number
	}
	return 0
}

func (m *Expression) GetList() *List {
	if x, ok := m.GetValue().(*Expression_List); ok {
		return x.List
	}
	return nil
}

func (m *Expression) GetCondition() *Condition {
	if x, ok := m.GetValue().(*Expression_Condition); ok {
		return x.Condition
	}
	return nil
}

func (m *Expression) GetFn() *Fn {
	if x, ok := m.GetValue().(*Expression_Fn); ok {
		return x.Fn
	}
	return nil
}

func (m *Expression) GetLet() *Let {
	if x, ok := m.GetValue().(*Expression_Let); ok {
		return x.Let
	}
	return nil
}

func (m *Expression) GetApply() *Apply {
	if x, ok := m.GetValue().(*Expression_Apply); ok {
		return x.Apply
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Expression) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Expression_OneofMarshaler, _Expression_OneofUnmarshaler, _Expression_OneofSizer, []interface{}{
		(*Expression_Nil)(nil),
		(*Expression_Symbol)(nil),
		(*Expression_String_)(nil),
		(*Expression_Number)(nil),
		(*Expression_List)(nil),
		(*Expression_Condition)(nil),
		(*Expression_Fn)(nil),
		(*Expression_Let)(nil),
		(*Expression_Apply)(nil),
	}
}

func _Expression_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Expression)
	// value
	switch x := m.Value.(type) {
	case *Expression_Nil:
		t := uint64(0)
		if x.Nil {
			t = 1
		}
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Expression_Symbol:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Symbol)
	case *Expression_String_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.String_)
	case *Expression_Number:
		b.EncodeVarint(4<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.Number))
	case *Expression_List:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.List); err != nil {
			return err
		}
	case *Expression_Condition:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Condition); err != nil {
			return err
		}
	case *Expression_Fn:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Fn); err != nil {
			return err
		}
	case *Expression_Let:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Let); err != nil {
			return err
		}
	case *Expression_Apply:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Apply); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Expression.Value has unexpected type %T", x)
	}
	return nil
}

func _Expression_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Expression)
	switch tag {
	case 1: // value.nil
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Expression_Nil{x != 0}
		return true, err
	case 2: // value.symbol
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Expression_Symbol{x}
		return true, err
	case 3: // value.string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Expression_String_{x}
		return true, err
	case 4: // value.number
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &Expression_Number{math.Float64frombits(x)}
		return true, err
	case 5: // value.list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(List)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_List{msg}
		return true, err
	case 7: // value.condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Condition)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_Condition{msg}
		return true, err
	case 6: // value.fn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Fn)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_Fn{msg}
		return true, err
	case 8: // value.let
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Let)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_Let{msg}
		return true, err
	case 9: // value.apply
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Apply)
		err := b.DecodeMessage(msg)
		m.Value = &Expression_Apply{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Expression_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Expression)
	// value
	switch x := m.Value.(type) {
	case *Expression_Nil:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *Expression_Symbol:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Symbol)))
		n += len(x.Symbol)
	case *Expression_String_:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.String_)))
		n += len(x.String_)
	case *Expression_Number:
		n += proto.SizeVarint(4<<3 | proto.WireFixed64)
		n += 8
	case *Expression_List:
		s := proto.Size(x.List)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_Condition:
		s := proto.Size(x.Condition)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_Fn:
		s := proto.Size(x.Fn)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_Let:
		s := proto.Size(x.Let)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expression_Apply:
		s := proto.Size(x.Apply)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*List)(nil), "bmeg.List")
	proto.RegisterType((*Condition)(nil), "bmeg.Condition")
	proto.RegisterType((*Fn)(nil), "bmeg.Fn")
	proto.RegisterType((*Binding)(nil), "bmeg.Binding")
	proto.RegisterType((*Let)(nil), "bmeg.Let")
	proto.RegisterType((*Apply)(nil), "bmeg.Apply")
	proto.RegisterType((*Expression)(nil), "bmeg.Expression")
}

func init() { proto.RegisterFile("pico.proto", fileDescriptor7) }

var fileDescriptor7 = []byte{
	// 374 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x52, 0x4d, 0x6f, 0xe2, 0x30,
	0x10, 0xcd, 0x27, 0xc4, 0x83, 0xd8, 0x65, 0x7d, 0x58, 0x59, 0xab, 0xd5, 0x6e, 0x14, 0x90, 0xca,
	0x89, 0x03, 0x3d, 0xf4, 0x58, 0x95, 0xaa, 0x28, 0x07, 0x0e, 0xfd, 0x0b, 0xf9, 0x30, 0xc1, 0x52,
	0x62, 0x47, 0xb1, 0x83, 0xca, 0x7f, 0xee, 0x8f, 0xa8, 0x6c, 0x03, 0xe2, 0x40, 0xd4, 0xeb, 0xbc,
	0x37, 0x6f, 0xde, 0xbc, 0x19, 0x80, 0x96, 0x15, 0x62, 0xd5, 0x76, 0x42, 0x09, 0x1c, 0xe4, 0x0d,
	0xad, 0x92, 0x07, 0x08, 0x76, 0x4c, 0x2a, 0xfc, 0x1f, 0x42, 0xa6, 0x68, 0x23, 0x89, 0x1f, 0xfb,
	0xcb, 0xc9, 0x7a, 0xb6, 0xd2, 0xe8, 0xea, 0xed, 0xa3, 0xed, 0xa8, 0x94, 0x4c, 0xf0, 0xe4, 0x08,
	0xe8, 0x55, 0xf0, 0x92, 0x29, 0x26, 0x38, 0x9e, 0x03, 0x6a, 0x3b, 0x5a, 0xb2, 0x22, 0x53, 0x94,
	0xb8, 0xb1, 0x7b, 0xaf, 0x43, 0x4b, 0xaa, 0xae, 0x57, 0x07, 0xe2, 0x0d, 0x10, 0xe6, 0x80, 0xf6,
	0x59, 0x2d, 0xe9, 0x41, 0x88, 0x92, 0xf8, 0xf7, 0x49, 0xc9, 0x13, 0x78, 0x5b, 0x8e, 0x7f, 0x01,
	0xca, 0xba, 0xaa, 0x6f, 0x28, 0x57, 0x92, 0xb8, 0xb1, 0xbf, 0x44, 0xf8, 0x1f, 0x04, 0xb9, 0x28,
	0x4f, 0x43, 0xea, 0xc9, 0x33, 0x8c, 0x37, 0x8c, 0x97, 0x8c, 0x57, 0xf8, 0x07, 0x8c, 0xe4, 0xa9,
	0xc9, 0x45, 0x6d, 0xbc, 0x22, 0xbc, 0x00, 0xa0, 0x57, 0xe2, 0xa0, 0xc0, 0x16, 0xfc, 0x1d, 0xd5,
	0xc9, 0x44, 0xb9, 0xd5, 0xb1, 0x93, 0x27, 0xeb, 0xa9, 0xa5, 0x5e, 0xd4, 0xbf, 0x33, 0xf2, 0x0e,
	0xe1, 0x4b, 0xdb, 0xd6, 0x27, 0x9c, 0x40, 0xb4, 0xef, 0x79, 0xa1, 0x13, 0x1c, 0x0c, 0x6d, 0x7e,
	0xbb, 0xa8, 0x37, 0x70, 0x8b, 0x4f, 0x17, 0xe0, 0xa6, 0x67, 0x0a, 0x3e, 0x67, 0x76, 0xb7, 0x28,
	0x75, 0xf0, 0xec, 0xba, 0xad, 0x76, 0x84, 0xce, 0x15, 0xd5, 0x31, 0x5e, 0x99, 0x94, 0xcf, 0x15,
	0xde, 0x37, 0x39, 0xed, 0x48, 0x10, 0xbb, 0x4b, 0x37, 0x75, 0xf0, 0x1f, 0x08, 0x6a, 0x26, 0x15,
	0x09, 0x8d, 0x31, 0xb0, 0x33, 0xf5, 0x6b, 0xa4, 0x0e, 0x5e, 0x00, 0x2a, 0x2e, 0xb7, 0x27, 0x63,
	0x43, 0xf8, 0x69, 0x09, 0xd7, 0x97, 0x48, 0x1d, 0xfc, 0x1b, 0xbc, 0x3d, 0x27, 0x23, 0x03, 0x47,
	0x16, 0xde, 0xea, 0x3a, 0x01, 0xbf, 0xa6, 0x8a, 0x44, 0x06, 0x40, 0x67, 0x61, 0xaa, 0x75, 0xff,
	0x42, 0x98, 0xe9, 0x64, 0x08, 0x32, 0xd8, 0xc4, 0x62, 0x26, 0xac, 0xd4, 0xd9, 0x8c, 0x21, 0x3c,
	0x66, 0x75, 0x4f, 0xf3, 0x91, 0x79, 0xd8, 0xc7, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc4, 0x7b,
	0x01, 0xf1, 0xbe, 0x02, 0x00, 0x00,
}
